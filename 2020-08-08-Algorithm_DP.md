# [Algorithm] Dynamic Programming

> 동적 계획법

- 어렵거나 큰 문제를 간단하고 작은 여러 개의 문제로 분할
    - 최적 부분 구조
        - 문제의 정답이 작은 문제에 대해서도 정답이어야 함, 즉 전체 문제 정답은 작은 문제들의 답을 이용해 구할 수 있어야 함
    - 부분 문제 반복
        - 문제를 여러 개의 작은 문제로 나눌 수 있어야 함, 이러한 작은 문제를 바탕으로 전체 문제를 푸는 방법과 동일한 방법으로 풀 수 있어야 함

> ### Memoization
>
> - 동일한 계산의 반복시 한 번 계산한 결과를 메모리에 저장해두었다가 꺼내씀으로써 중복 계산을 방지할 수 있게 하는 기법
>     * Example
>         * 점화식



## Types of DP

- Bottom-up (상향식)

    - 작은 문제에서 시작해 큰 문제를 풀 수 있을 때까지 차례로 문제 정답 도출

    - 주로 **반복문을 이용한 구현**

        ```c
        int d[101010] = {1, 1};
        for (int i = 2; i <= n; ++i)
          d[i] = d[i-1] + d[i-2];
        ```

        

- Top-down (하향식)

    - 큰 문제를 풀 수 있는 작은 문제가 될 때까지 나누어 이들 문제를 합쳐가며 큰 문제의 정답 도출

    - 주로 **재귀함수를 이용한 구현**

        ```c
        int d[101010];
        int fibo(int n) {
          if (n <= 1) return 1;
          int &res = d[n];
          if (res) return res;
          return res = fibo(n-1) + fibo(n-2);
        }
        ```

